import os
import csv
import subprocess
import logging
import psutil
import shutil
import stat
from dotenv import load_dotenv
import time

# üìÑ Carregando vari√°veis de ambiente
script_dir = os.path.dirname(os.path.abspath(__file__))
env_path = os.path.abspath(os.path.join(script_dir, "..", "..", ".env.config"))

if os.path.exists(env_path):
    load_dotenv(dotenv_path=env_path)
else:
    raise FileNotFoundError(f"‚ùå ERRO: O arquivo .env.config N√ÉO foi encontrado: {env_path}")

TOKEN = os.getenv("GITHUB_TOKEN")
if not TOKEN:
    raise ValueError("‚ùå ERRO: Token GITHUB_TOKEN n√£o foi encontrado no .env.config üîê")

BASE_DIR = os.path.abspath(os.path.dirname(__file__))
DATA_DIR = os.path.join(BASE_DIR, 'Data')
REPOS_LIST_FILE = os.path.join(DATA_DIR, 'repositorios_list.csv')

REPOS_DIR = os.path.join(BASE_DIR, 'Repos')
LOG_DIR = os.path.join(BASE_DIR, "Relat√≥rios")
LOG_FILE = os.path.join(LOG_DIR, "automacao_clone.log")
os.makedirs(LOG_DIR, exist_ok=True)

# ‚úÖ Configura√ß√£o do LOG sem o n√≠vel (INFO/WARNING) pra manter alinhado
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)-8s - %(message)s",
    handlers=[logging.StreamHandler(), logging.FileHandler(LOG_FILE, encoding="utf-8")]
)

log_info = logging.info
log_warning = logging.warning
log_error = logging.error

MEMORY_THRESHOLD_MB = 500
DISK_THRESHOLD_MB = 1024
MAX_RETRIES = 5

def recursos_suficientes():
    mem = psutil.virtual_memory()
    disk = psutil.disk_usage(REPOS_DIR)
    if mem.available / (1024 * 1024) < MEMORY_THRESHOLD_MB:
        logging.error("üõë Mem√≥ria insuficiente")
        return False
    if disk.free / (1024 * 1024) < DISK_THRESHOLD_MB:
        logging.error("üõë Espa√ßo em disco insuficiente")
        return False
    return True

def remove_readonly(func, path, excinfo):
    os.chmod(path, stat.S_IWRITE)
    func(path)

def repositorio_clonado_completo(repo_path):
    return os.path.isdir(os.path.join(repo_path, '.git'))

def fetch_and_compare(repo_path):
    try:
        subprocess.run(['git', '-C', repo_path, 'fetch'], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        branch = subprocess.check_output(['git', '-C', repo_path, 'rev-parse', '--abbrev-ref', 'HEAD'], stderr=subprocess.DEVNULL).strip().decode()
        remote_commit = subprocess.check_output(['git', '-C', repo_path, 'rev-parse', f'origin/{branch}'], stderr=subprocess.DEVNULL).strip()
        local_commit = subprocess.check_output(['git', '-C', repo_path, 'rev-parse', 'HEAD'], stderr=subprocess.DEVNULL).strip()
        return local_commit == remote_commit
    except subprocess.CalledProcessError:
        return False

def clonar_repositorios():
    if not os.path.exists(REPOS_LIST_FILE):
        raise FileNotFoundError(f"üìÑ Lista de reposit√≥rios n√£o encontrada: {REPOS_LIST_FILE}")

    os.makedirs(REPOS_DIR, exist_ok=True)
    with open(REPOS_LIST_FILE, newline='', encoding='utf-8') as csvfile:
        csv_reader = csv.reader(csvfile)
        next(csv_reader, None)
        repositorios = list(csv_reader)

    total_repos = len(repositorios)
    cloned_count = 0

    for idx, row in enumerate(repositorios, start=1):
        if not row:
            continue

        repo_url = row[0].strip()
        repo_name = repo_url.split('/')[-1].replace('.git', '')
        repo_path = os.path.join(REPOS_DIR, repo_name)

        idx_display = f"{idx:02}"
        log_prefix = f"({idx_display}/{total_repos})"
        padding = ' ' * len(log_prefix)

        logging.info(f"{log_prefix} üìÇ Processando: \033[33m{repo_name}\033[0m")

        if os.path.exists(repo_path):
            logging.info(f"{padding} üîé Verificando se o reposit√≥rio \033[35m{repo_name}\033[0m est√° atualizado...")
            if repositorio_clonado_completo(repo_path) and fetch_and_compare(repo_path):
                logging.info(f"{padding} ‚úÖ \033[35m{repo_name}\033[0m est√° atualizado e n√£o ser√° re-clonado.")
                continue
            else:
                logging.warning(f"{padding} ‚ö†Ô∏è \033[35m{repo_name}\033[0m est√° incompleto ou desatualizado. Excluindo e re-clonando...")
                shutil.rmtree(repo_path, onerror=remove_readonly)

        if not recursos_suficientes():
            logging.error(f"{padding} üõë Recursos insuficientes! Encerrando... ({idx_display}/{total_repos})")
            break

        attempt = 0
        success = False
        while attempt < MAX_RETRIES:
            try:
                logging.info(f"{padding} üîÑ Clonando \033[35m{repo_name}\033[0m...")
                subprocess.run(['git', 'clone', repo_url, repo_path], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                logging.info(f"{padding} üîç Comparando reposit√≥rio local e remoto ap√≥s a clonagem...")
                success = fetch_and_compare(repo_path)
                if success:
                    break
                else:
                    logging.warning(f"{padding} ‚ö†Ô∏è Reposit√≥rio clonado incompleto, tentando novamente...")
                    shutil.rmtree(repo_path, onerror=remove_readonly)
            except subprocess.CalledProcessError:
                attempt += 1
                logging.warning(f"{padding} ‚ö†Ô∏è Erro ao clonar, tentativa {attempt}/{MAX_RETRIES}")
                time.sleep(5)

        if not success:
            logging.error(f"{padding} ‚ùå Falha ao clonar \033[35m{repo_name}\033[0m ap√≥s {MAX_RETRIES} tentativas.")
        else:
            cloned_count += 1
            logging.info(f"{padding} ‚úÖ Clonado com sucesso: \033[35m{repo_name}\033[0m (Total: {cloned_count})")

    logging.info(f"üéØ Clonagem finalizada! Total clonado: {cloned_count} de {total_repos}")

def contar_repositorios_clonados():
    if not os.path.exists(REPOS_DIR):
        logging.error(f"‚ùå Diret√≥rio n√£o encontrado: {REPOS_DIR}")
        return 0

    total = 0
    for pasta in os.listdir(REPOS_DIR):
        repo_path = os.path.join(REPOS_DIR, pasta)
        if os.path.isdir(repo_path) and os.path.isdir(os.path.join(repo_path, '.git')):
            total += 1
        else:
            logging.warning(f"‚ö†Ô∏è Reposit√≥rio inv√°lido ou incompleto: {pasta}")

    logging.info(f"üìà Total de reposit√≥rios clonados na pasta: {total}")

    if total < 1000:
        logging.warning(f"‚ö†Ô∏è Apenas {total} reposit√≥rios encontrados. Esperado: 1000")
    elif total > 1000:
        logging.warning(f"‚ö†Ô∏è Aten√ß√£o! {total} reposit√≥rios encontrados, mais que o esperado.")
    else:
        logging.info(f"‚úÖ Todos os 1000 reposit√≥rios clonados com sucesso!")

    return total

if __name__ == "__main__":
    logging.info("üöÄ Iniciando o processo de clonagem dos reposit√≥rios...\n")
    clonar_repositorios()
    total_clonados = contar_repositorios_clonados()

    if total_clonados == 1000:
        logging.info("üéâ Quantidade correta de reposit√≥rios clonados! Pronto para a pr√≥xima etapa.")
    else:
        logging.error(f"‚ùå Foram encontrados {total_clonados} reposit√≥rios. Esperado: 1000. Verifique! üìå")